package twoPointer;

import org.junit.Assert;
import org.junit.Test;

public class RemovepalindromeSubSequence {
    int count=0;
    /*
    You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

    Return the minimum number of steps to make the given string empty.

    A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.

    A string is called palindrome if is one that reads the same backward as well as forward.



            Example 1:

    Input: s = "ababa"
    Output: 1
    Explanation: s is already a palindrome, so its entirety can be removed in a single step.
    Example 2:

    Input: s = "abb"
    Output: 2
    Explanation: "abb" -> "bb" -> "".
    Remove palindromic subsequence "a" then "bb".
    Example 3:

    Input: s = "baabb"
    Output: 2
    Explanation: "baabb" -> "b" -> "".
    Remove palindromic subsequence "baab" then "b".


    Constraints:

            1 <= s.length <= 1000
    s[i] is either 'a' or 'b'.
     */
    @Test
    public void test1(){
        String s="ababa";
        Assert.assertEquals(removeSubSequencesOptmized(s),1);
    }
    @Test
    public void test2(){
        String s="abb";
        Assert.assertEquals(removeSubSequencesOptmized(s),2);
    }
    @Test
    public void test3(){
        String s= "bbaabaaa";
        Assert.assertEquals(removeSubSequencesOptmized(s),2);
    }


     /*
        Input- String
        Output- Integer

        Soltion:-
        - Initialize two pointer left=0, right=0, palindrome_index=0, counter=0
        -  iterate the char array from start index until end
        - get the substring and check if its a palindrome
        - if yes, update the palindrome_index and check for any other longer length possibilities
        - If there is a one hit, before length, update the index
        - else try to remove the substring until the palindrom index, update the counter
        - move the left and righ to one index after the palindrome index
        -  return the counter
        */

    // own solution- only gets through 50% of test cases
    private int removeSubSequences(String s) {
        int left=0, right=0,palindromeIndex=0;
        StringBuilder temp=new StringBuilder();
        while(right<s.length()){
            temp.append(s.charAt(right));
            if(temp.reverse().toString().equals(s.substring(left,right+1))){
                palindromeIndex=right;
            }
            temp.reverse();
            right++;
        }
        if(palindromeIndex==s.length()-1){
            count++;
            return 1;
        }
        else{
            count++;
            removeSubSequences(s.substring(palindromeIndex+1));
        }
        return count;
    }

    /*
    - initialize two pointers left=0, right=length-1
    - while left< right, iterate the string
    - if the value at left and right are same, decrement right and increment left
    - else return 2
     */
    private int removeSubSequencesRefferred(String s) {
        if(s.length()==0) return 0;
        int left=0, right=s.length()-1;
        while (left<right){
            if(s.charAt(left++)==s.charAt(right--));
            else return 2;
        }
        return 1;
    }
    private int removeSubSequencesOptmized(String s) {
        if(s.length()==0) return 0;
       return s.length()==0?0: s.equals(new StringBuffer(s).reverse().toString())?1:2;
    }
}
